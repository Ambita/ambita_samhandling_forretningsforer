/*
 * (title)
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.client.model.BasicResponseForretningsforer;
import org.openapitools.client.model.BestillingsFormat;
import org.openapitools.client.model.BoliginformasjonResponse;
import org.openapitools.client.model.EndringKjopereFullfort;
import org.openapitools.client.model.EndringKjopereMottatt;
import org.openapitools.client.model.EndringOverdragelseBehandlet;
import org.openapitools.client.model.Feil;
import org.openapitools.client.model.Feilkode;
import org.openapitools.client.model.ForhandsutlysingSen;
import org.openapitools.client.model.ForhandsutlysingTidlig;
import org.openapitools.client.model.ForhandsutlysingUtlopt;
import org.openapitools.client.model.ForhandsutlysingUtsatt;
import org.openapitools.client.model.Klient;
import org.openapitools.client.model.Kontakt;
import org.openapitools.client.model.SalgsmeldingForkjopsrettFullfort;
import org.openapitools.client.model.SalgsmeldingFullfort;
import org.openapitools.client.model.SalgsmeldingMottatt;
import org.openapitools.client.model.SalgsmeldingOppdatering;
import org.openapitools.client.model.SluttbrevAkseptert;
import org.openapitools.client.model.StyregodkjenningFullfort;
import org.openapitools.client.model.SumFelleskostnaderSvar;
import org.openapitools.client.model.SumGjeldSvar;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


import java.io.IOException;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.SerializerProvider;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;
import com.fasterxml.jackson.databind.deser.std.StdDeserializer;
import com.fasterxml.jackson.databind.ser.std.StdSerializer;
import org.openapitools.client.ApiClient;
import org.openapitools.client.JSON;

@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-08-25T20:06:52.009382+02:00[Europe/Oslo]", comments = "Generator version: 7.15.0")
@JsonDeserialize(using=CallbackEvent.CallbackEventDeserializer.class)
@JsonSerialize(using = CallbackEvent.CallbackEventSerializer.class)
public class CallbackEvent extends AbstractOpenApiSchema {
    private static final Logger log = Logger.getLogger(CallbackEvent.class.getName());

    public static class CallbackEventSerializer extends StdSerializer<CallbackEvent> {
        public CallbackEventSerializer(Class<CallbackEvent> t) {
            super(t);
        }

        public CallbackEventSerializer() {
            this(null);
        }

        @Override
        public void serialize(CallbackEvent value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {
            jgen.writeObject(value.getActualInstance());
        }
    }

    public static class CallbackEventDeserializer extends StdDeserializer<CallbackEvent> {
        public CallbackEventDeserializer() {
            this(CallbackEvent.class);
        }

        public CallbackEventDeserializer(Class<?> vc) {
            super(vc);
        }

        @Override
        public CallbackEvent deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException {
            JsonNode tree = jp.readValueAsTree();

            Object deserialized = null;
            // deserialize BoliginformasjonResponse
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(BoliginformasjonResponse.class);
                CallbackEvent ret = new CallbackEvent();
                ret.setActualInstance(deserialized);
                return ret;
            } catch (Exception e) {
                // deserialization failed, continue, log to help debugging
                log.log(Level.FINER, "Input data does not match 'CallbackEvent'", e);
            }

            // deserialize EndringKjopereFullfort
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(EndringKjopereFullfort.class);
                CallbackEvent ret = new CallbackEvent();
                ret.setActualInstance(deserialized);
                return ret;
            } catch (Exception e) {
                // deserialization failed, continue, log to help debugging
                log.log(Level.FINER, "Input data does not match 'CallbackEvent'", e);
            }

            // deserialize EndringKjopereMottatt
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(EndringKjopereMottatt.class);
                CallbackEvent ret = new CallbackEvent();
                ret.setActualInstance(deserialized);
                return ret;
            } catch (Exception e) {
                // deserialization failed, continue, log to help debugging
                log.log(Level.FINER, "Input data does not match 'CallbackEvent'", e);
            }

            // deserialize EndringOverdragelseBehandlet
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(EndringOverdragelseBehandlet.class);
                CallbackEvent ret = new CallbackEvent();
                ret.setActualInstance(deserialized);
                return ret;
            } catch (Exception e) {
                // deserialization failed, continue, log to help debugging
                log.log(Level.FINER, "Input data does not match 'CallbackEvent'", e);
            }

            // deserialize Feil
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(Feil.class);
                CallbackEvent ret = new CallbackEvent();
                ret.setActualInstance(deserialized);
                return ret;
            } catch (Exception e) {
                // deserialization failed, continue, log to help debugging
                log.log(Level.FINER, "Input data does not match 'CallbackEvent'", e);
            }

            // deserialize ForhandsutlysingSen
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(ForhandsutlysingSen.class);
                CallbackEvent ret = new CallbackEvent();
                ret.setActualInstance(deserialized);
                return ret;
            } catch (Exception e) {
                // deserialization failed, continue, log to help debugging
                log.log(Level.FINER, "Input data does not match 'CallbackEvent'", e);
            }

            // deserialize ForhandsutlysingTidlig
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(ForhandsutlysingTidlig.class);
                CallbackEvent ret = new CallbackEvent();
                ret.setActualInstance(deserialized);
                return ret;
            } catch (Exception e) {
                // deserialization failed, continue, log to help debugging
                log.log(Level.FINER, "Input data does not match 'CallbackEvent'", e);
            }

            // deserialize ForhandsutlysingUtlopt
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(ForhandsutlysingUtlopt.class);
                CallbackEvent ret = new CallbackEvent();
                ret.setActualInstance(deserialized);
                return ret;
            } catch (Exception e) {
                // deserialization failed, continue, log to help debugging
                log.log(Level.FINER, "Input data does not match 'CallbackEvent'", e);
            }

            // deserialize ForhandsutlysingUtsatt
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(ForhandsutlysingUtsatt.class);
                CallbackEvent ret = new CallbackEvent();
                ret.setActualInstance(deserialized);
                return ret;
            } catch (Exception e) {
                // deserialization failed, continue, log to help debugging
                log.log(Level.FINER, "Input data does not match 'CallbackEvent'", e);
            }

            // deserialize SalgsmeldingFullfort
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(SalgsmeldingFullfort.class);
                CallbackEvent ret = new CallbackEvent();
                ret.setActualInstance(deserialized);
                return ret;
            } catch (Exception e) {
                // deserialization failed, continue, log to help debugging
                log.log(Level.FINER, "Input data does not match 'CallbackEvent'", e);
            }

            // deserialize SalgsmeldingMottatt
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(SalgsmeldingMottatt.class);
                CallbackEvent ret = new CallbackEvent();
                ret.setActualInstance(deserialized);
                return ret;
            } catch (Exception e) {
                // deserialization failed, continue, log to help debugging
                log.log(Level.FINER, "Input data does not match 'CallbackEvent'", e);
            }

            // deserialize SalgsmeldingOppdatering
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(SalgsmeldingOppdatering.class);
                CallbackEvent ret = new CallbackEvent();
                ret.setActualInstance(deserialized);
                return ret;
            } catch (Exception e) {
                // deserialization failed, continue, log to help debugging
                log.log(Level.FINER, "Input data does not match 'CallbackEvent'", e);
            }

            // deserialize SluttbrevAkseptert
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(SluttbrevAkseptert.class);
                CallbackEvent ret = new CallbackEvent();
                ret.setActualInstance(deserialized);
                return ret;
            } catch (Exception e) {
                // deserialization failed, continue, log to help debugging
                log.log(Level.FINER, "Input data does not match 'CallbackEvent'", e);
            }

            // deserialize SumFelleskostnaderSvar
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(SumFelleskostnaderSvar.class);
                CallbackEvent ret = new CallbackEvent();
                ret.setActualInstance(deserialized);
                return ret;
            } catch (Exception e) {
                // deserialization failed, continue, log to help debugging
                log.log(Level.FINER, "Input data does not match 'CallbackEvent'", e);
            }

            // deserialize SumGjeldSvar
            try {
                deserialized = tree.traverse(jp.getCodec()).readValueAs(SumGjeldSvar.class);
                CallbackEvent ret = new CallbackEvent();
                ret.setActualInstance(deserialized);
                return ret;
            } catch (Exception e) {
                // deserialization failed, continue, log to help debugging
                log.log(Level.FINER, "Input data does not match 'CallbackEvent'", e);
            }

            throw new IOException(String.format("Failed deserialization for CallbackEvent: no match found"));
        }

        /**
         * Handle deserialization of the 'null' value.
         */
        @Override
        public CallbackEvent getNullValue(DeserializationContext ctxt) throws JsonMappingException {
            throw new JsonMappingException(ctxt.getParser(), "CallbackEvent cannot be null");
        }
    }

    // store a list of schema names defined in anyOf
    public static final Map<String, Class<?>> schemas = new HashMap<String, Class<?>>();

    public CallbackEvent() {
        super("anyOf", Boolean.FALSE);
    }

    public CallbackEvent(BoliginformasjonResponse o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CallbackEvent(EndringKjopereFullfort o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CallbackEvent(EndringKjopereMottatt o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CallbackEvent(EndringOverdragelseBehandlet o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CallbackEvent(Feil o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CallbackEvent(ForhandsutlysingSen o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CallbackEvent(ForhandsutlysingTidlig o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CallbackEvent(ForhandsutlysingUtlopt o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CallbackEvent(ForhandsutlysingUtsatt o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CallbackEvent(SalgsmeldingFullfort o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CallbackEvent(SalgsmeldingMottatt o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CallbackEvent(SalgsmeldingOppdatering o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CallbackEvent(SluttbrevAkseptert o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CallbackEvent(SumFelleskostnaderSvar o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    public CallbackEvent(SumGjeldSvar o) {
        super("anyOf", Boolean.FALSE);
        setActualInstance(o);
    }

    static {
        schemas.put("BoliginformasjonResponse", BoliginformasjonResponse.class);
        schemas.put("EndringKjopereFullfort", EndringKjopereFullfort.class);
        schemas.put("EndringKjopereMottatt", EndringKjopereMottatt.class);
        schemas.put("EndringOverdragelseBehandlet", EndringOverdragelseBehandlet.class);
        schemas.put("Feil", Feil.class);
        schemas.put("ForhandsutlysingSen", ForhandsutlysingSen.class);
        schemas.put("ForhandsutlysingTidlig", ForhandsutlysingTidlig.class);
        schemas.put("ForhandsutlysingUtlopt", ForhandsutlysingUtlopt.class);
        schemas.put("ForhandsutlysingUtsatt", ForhandsutlysingUtsatt.class);
        schemas.put("SalgsmeldingFullfort", SalgsmeldingFullfort.class);
        schemas.put("SalgsmeldingMottatt", SalgsmeldingMottatt.class);
        schemas.put("SalgsmeldingOppdatering", SalgsmeldingOppdatering.class);
        schemas.put("SluttbrevAkseptert", SluttbrevAkseptert.class);
        schemas.put("SumFelleskostnaderSvar", SumFelleskostnaderSvar.class);
        schemas.put("SumGjeldSvar", SumGjeldSvar.class);
        JSON.registerDescendants(CallbackEvent.class, Collections.unmodifiableMap(schemas));
    }

    @Override
    public Map<String, Class<?>> getSchemas() {
        return CallbackEvent.schemas;
    }

    /**
     * Set the instance that matches the anyOf child schema, check
     * the instance parameter is valid against the anyOf child schemas:
     * BoliginformasjonResponse, EndringKjopereFullfort, EndringKjopereMottatt, EndringOverdragelseBehandlet, Feil, ForhandsutlysingSen, ForhandsutlysingTidlig, ForhandsutlysingUtlopt, ForhandsutlysingUtsatt, SalgsmeldingFullfort, SalgsmeldingMottatt, SalgsmeldingOppdatering, SluttbrevAkseptert, SumFelleskostnaderSvar, SumGjeldSvar
     *
     * It could be an instance of the 'anyOf' schemas.
     * The anyOf child schemas may themselves be a composed schema (allOf, anyOf, anyOf).
     */
    @Override
    public void setActualInstance(Object instance) {
        if (JSON.isInstanceOf(BoliginformasjonResponse.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(EndringKjopereFullfort.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(EndringKjopereMottatt.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(EndringOverdragelseBehandlet.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(Feil.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ForhandsutlysingSen.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ForhandsutlysingTidlig.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ForhandsutlysingUtlopt.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(ForhandsutlysingUtsatt.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(SalgsmeldingFullfort.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(SalgsmeldingMottatt.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(SalgsmeldingOppdatering.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(SluttbrevAkseptert.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(SumFelleskostnaderSvar.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        if (JSON.isInstanceOf(SumGjeldSvar.class, instance, new HashSet<Class<?>>())) {
            super.setActualInstance(instance);
            return;
        }

        throw new RuntimeException("Invalid instance type. Must be BoliginformasjonResponse, EndringKjopereFullfort, EndringKjopereMottatt, EndringOverdragelseBehandlet, Feil, ForhandsutlysingSen, ForhandsutlysingTidlig, ForhandsutlysingUtlopt, ForhandsutlysingUtsatt, SalgsmeldingFullfort, SalgsmeldingMottatt, SalgsmeldingOppdatering, SluttbrevAkseptert, SumFelleskostnaderSvar, SumGjeldSvar");
    }

    /**
     * Get the actual instance, which can be the following:
     * BoliginformasjonResponse, EndringKjopereFullfort, EndringKjopereMottatt, EndringOverdragelseBehandlet, Feil, ForhandsutlysingSen, ForhandsutlysingTidlig, ForhandsutlysingUtlopt, ForhandsutlysingUtsatt, SalgsmeldingFullfort, SalgsmeldingMottatt, SalgsmeldingOppdatering, SluttbrevAkseptert, SumFelleskostnaderSvar, SumGjeldSvar
     *
     * @return The actual instance (BoliginformasjonResponse, EndringKjopereFullfort, EndringKjopereMottatt, EndringOverdragelseBehandlet, Feil, ForhandsutlysingSen, ForhandsutlysingTidlig, ForhandsutlysingUtlopt, ForhandsutlysingUtsatt, SalgsmeldingFullfort, SalgsmeldingMottatt, SalgsmeldingOppdatering, SluttbrevAkseptert, SumFelleskostnaderSvar, SumGjeldSvar)
     */
    @Override
    public Object getActualInstance() {
        return super.getActualInstance();
    }

    /**
     * Get the actual instance of `BoliginformasjonResponse`. If the actual instance is not `BoliginformasjonResponse`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `BoliginformasjonResponse`
     * @throws ClassCastException if the instance is not `BoliginformasjonResponse`
     */
    public BoliginformasjonResponse getBoliginformasjonResponse() throws ClassCastException {
        return (BoliginformasjonResponse)super.getActualInstance();
    }

    /**
     * Get the actual instance of `EndringKjopereFullfort`. If the actual instance is not `EndringKjopereFullfort`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EndringKjopereFullfort`
     * @throws ClassCastException if the instance is not `EndringKjopereFullfort`
     */
    public EndringKjopereFullfort getEndringKjopereFullfort() throws ClassCastException {
        return (EndringKjopereFullfort)super.getActualInstance();
    }

    /**
     * Get the actual instance of `EndringKjopereMottatt`. If the actual instance is not `EndringKjopereMottatt`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EndringKjopereMottatt`
     * @throws ClassCastException if the instance is not `EndringKjopereMottatt`
     */
    public EndringKjopereMottatt getEndringKjopereMottatt() throws ClassCastException {
        return (EndringKjopereMottatt)super.getActualInstance();
    }

    /**
     * Get the actual instance of `EndringOverdragelseBehandlet`. If the actual instance is not `EndringOverdragelseBehandlet`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `EndringOverdragelseBehandlet`
     * @throws ClassCastException if the instance is not `EndringOverdragelseBehandlet`
     */
    public EndringOverdragelseBehandlet getEndringOverdragelseBehandlet() throws ClassCastException {
        return (EndringOverdragelseBehandlet)super.getActualInstance();
    }

    /**
     * Get the actual instance of `Feil`. If the actual instance is not `Feil`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `Feil`
     * @throws ClassCastException if the instance is not `Feil`
     */
    public Feil getFeil() throws ClassCastException {
        return (Feil)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ForhandsutlysingSen`. If the actual instance is not `ForhandsutlysingSen`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ForhandsutlysingSen`
     * @throws ClassCastException if the instance is not `ForhandsutlysingSen`
     */
    public ForhandsutlysingSen getForhandsutlysingSen() throws ClassCastException {
        return (ForhandsutlysingSen)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ForhandsutlysingTidlig`. If the actual instance is not `ForhandsutlysingTidlig`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ForhandsutlysingTidlig`
     * @throws ClassCastException if the instance is not `ForhandsutlysingTidlig`
     */
    public ForhandsutlysingTidlig getForhandsutlysingTidlig() throws ClassCastException {
        return (ForhandsutlysingTidlig)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ForhandsutlysingUtlopt`. If the actual instance is not `ForhandsutlysingUtlopt`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ForhandsutlysingUtlopt`
     * @throws ClassCastException if the instance is not `ForhandsutlysingUtlopt`
     */
    public ForhandsutlysingUtlopt getForhandsutlysingUtlopt() throws ClassCastException {
        return (ForhandsutlysingUtlopt)super.getActualInstance();
    }

    /**
     * Get the actual instance of `ForhandsutlysingUtsatt`. If the actual instance is not `ForhandsutlysingUtsatt`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `ForhandsutlysingUtsatt`
     * @throws ClassCastException if the instance is not `ForhandsutlysingUtsatt`
     */
    public ForhandsutlysingUtsatt getForhandsutlysingUtsatt() throws ClassCastException {
        return (ForhandsutlysingUtsatt)super.getActualInstance();
    }

    /**
     * Get the actual instance of `SalgsmeldingFullfort`. If the actual instance is not `SalgsmeldingFullfort`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SalgsmeldingFullfort`
     * @throws ClassCastException if the instance is not `SalgsmeldingFullfort`
     */
    public SalgsmeldingFullfort getSalgsmeldingFullfort() throws ClassCastException {
        return (SalgsmeldingFullfort)super.getActualInstance();
    }

    /**
     * Get the actual instance of `SalgsmeldingMottatt`. If the actual instance is not `SalgsmeldingMottatt`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SalgsmeldingMottatt`
     * @throws ClassCastException if the instance is not `SalgsmeldingMottatt`
     */
    public SalgsmeldingMottatt getSalgsmeldingMottatt() throws ClassCastException {
        return (SalgsmeldingMottatt)super.getActualInstance();
    }

    /**
     * Get the actual instance of `SalgsmeldingOppdatering`. If the actual instance is not `SalgsmeldingOppdatering`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SalgsmeldingOppdatering`
     * @throws ClassCastException if the instance is not `SalgsmeldingOppdatering`
     */
    public SalgsmeldingOppdatering getSalgsmeldingOppdatering() throws ClassCastException {
        return (SalgsmeldingOppdatering)super.getActualInstance();
    }

    /**
     * Get the actual instance of `SluttbrevAkseptert`. If the actual instance is not `SluttbrevAkseptert`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SluttbrevAkseptert`
     * @throws ClassCastException if the instance is not `SluttbrevAkseptert`
     */
    public SluttbrevAkseptert getSluttbrevAkseptert() throws ClassCastException {
        return (SluttbrevAkseptert)super.getActualInstance();
    }

    /**
     * Get the actual instance of `SumFelleskostnaderSvar`. If the actual instance is not `SumFelleskostnaderSvar`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SumFelleskostnaderSvar`
     * @throws ClassCastException if the instance is not `SumFelleskostnaderSvar`
     */
    public SumFelleskostnaderSvar getSumFelleskostnaderSvar() throws ClassCastException {
        return (SumFelleskostnaderSvar)super.getActualInstance();
    }

    /**
     * Get the actual instance of `SumGjeldSvar`. If the actual instance is not `SumGjeldSvar`,
     * the ClassCastException will be thrown.
     *
     * @return The actual instance of `SumGjeldSvar`
     * @throws ClassCastException if the instance is not `SumGjeldSvar`
     */
    public SumGjeldSvar getSumGjeldSvar() throws ClassCastException {
        return (SumGjeldSvar)super.getActualInstance();
    }



  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    return null;
  }

}

